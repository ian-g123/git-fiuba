use std::{
    collections::HashMap,
    fs::{self, Metadata},
    io::{Read, Write},
};

use crate::{
    join_paths,
    logger::Logger,
    objects::{
        blob::Blob,
        git_object::{GitObject, GitObjectTrait},
        mode::Mode,
    },
    objects_database::ObjectsDatabase,
    utils::{aux::get_name, super_string::u8_vec_to_hex_string},
};

use super::{
    super::{command_errors::CommandError, objects::tree::Tree},
    index_entry::IndexEntry,
    merge_stage::MergeStage,
};

#[derive(Debug, Clone, PartialEq)]
pub struct StagingArea {
    files: HashMap<String, IndexEntry>,
    pub soft_files: HashMap<String, String>,

    unmerged_files: HashMap<String, (Option<IndexEntry>, Option<IndexEntry>, Option<IndexEntry>)>,
    pub soft_unmerged_files: HashMap<String, (Option<String>, Option<String>, Option<String>)>,

    index_path: String,
}

impl StagingArea {
    fn new(index_path: &str) -> Self {
        Self {
            files: HashMap::new(),
            soft_files: HashMap::new(),

            unmerged_files: HashMap::new(),
            soft_unmerged_files: HashMap::new(),

            index_path: index_path.to_string(),
        }
    }

    pub fn get_files(&self) -> HashMap<String, String> {
        let mut files: HashMap<String, String> = HashMap::new();
        for (path, entry) in self.files.iter() {
            _ = files.insert(path.to_string(), u8_vec_to_hex_string(&entry.sha1));
        }
        files
    }

    pub fn get_hash_from_path(&self, path: &str) -> Result<String, CommandError> {
        match self.get_files().get(path) {
            Some(hash) => Ok(hash.to_string()),
            None => Err(CommandError::RmFromStagingAreaError(path.to_string())),
        }
    }

    pub fn is_in_staging_area(&self, path: &String) -> bool {
        return self.files.contains_key(path);
    }

    pub fn get_unmerged_files(
        &self,
    ) -> HashMap<String, (Option<String>, Option<String>, Option<String>)> {
        let mut files: HashMap<String, (Option<String>, Option<String>, Option<String>)> =
            HashMap::new();
        for (path, (common_entry, head_entry, destin_entry)) in self.unmerged_files.iter() {
            let common_hash = {
                if let Some(common) = common_entry {
                    Some(u8_vec_to_hex_string(&common.sha1))
                } else {
                    None
                }
            };
            let head_hash = {
                if let Some(head) = head_entry {
                    Some(u8_vec_to_hex_string(&head.sha1))
                } else {
                    None
                }
            };
            let destin_hash = {
                if let Some(destin) = destin_entry {
                    Some(u8_vec_to_hex_string(&destin.sha1))
                } else {
                    None
                }
            };
            _ = files.insert(path.to_string(), (common_hash, head_hash, destin_hash));
        }
        files
    }

    pub fn get_changes(
        &self,
        last_commit_tree: &Option<Tree>,
        logger: &mut Logger,
    ) -> Result<HashMap<String, String>, CommandError> {
        let mut changes: HashMap<String, String> = HashMap::new();
        if let Some(mut tree) = last_commit_tree.clone() {
            for (path, hash) in self.get_files().iter() {
                let (is_in_last_commit, name) = tree.has_blob_from_hash(hash, logger)?;

                if !is_in_last_commit || get_name(path)? != name {
                    _ = changes.insert(path.to_string(), hash.to_string())
                }
            }
        } else {
            changes = self.get_files().clone()
        }
        Ok(changes)
    }

    pub fn remove_entry(&mut self, path: &str, logger: &mut Logger) -> Result<(), CommandError> {
        if !self.is_in_staging_area(&path.to_string()) {
            return Err(CommandError::RmFromStagingAreaError(path.to_string()));
        }
        self.remove(path);
        Ok(())
    }

    pub fn has_changes(
        &self,
        _db: &ObjectsDatabase,
        last_commit_tree: &Option<Tree>,
        logger: &mut Logger,
    ) -> Result<bool, CommandError> {
        let changes = self.get_changes(last_commit_tree, logger)?.len();
        let deleted_files = self.get_deleted_files(last_commit_tree);
        Ok(changes + deleted_files.len() > 0)
    }

    pub fn get_deleted_files(&self, last_commit_tree: &Option<Tree>) -> Vec<String> {
        let mut deleted: Vec<String> = Vec::new();
        if let Some(mut tree) = last_commit_tree.clone() {
            self.check_deleted_from_commit(&mut tree, &mut deleted, "".to_string())
        }
        deleted
    }

    fn check_deleted_from_commit(&self, tree: &mut Tree, deleted: &mut Vec<String>, path: String) {
        for (name, (_, object_opt)) in tree.get_objects().iter_mut() {
            let complete_path = {
                if path == "".to_string() {
                    format!("{}", name)
                } else {
                    format!("{}/{}", path, name)
                }
            };
            let Some(object) = object_opt else {
                continue;
            };
            if let Some(new_tree) = object.as_mut_tree() {
                self.check_deleted_from_commit(new_tree, deleted, complete_path);
            } else {
                if !self.has_file_from_path(&complete_path) {
                    _ = deleted.push(complete_path);
                }
            }
        }
    }

    pub fn has_file_from_path(&self, path: &str) -> bool {
        self.get_files().contains_key(path) || self.unmerged_files.contains_key(path)
    }

    /// Verifica si hay un cambio del working tree respecto del staging area
    pub fn has_file_renamed(&self, actual_path: &str, actual_hash: &str) -> bool {
        for (path, hash) in self.get_files() {
            let mut actual_parts: Vec<&str> = actual_path.split_terminator("/").collect();
            let mut parts: Vec<&str> = path.split_terminator("/").collect();

            _ = actual_parts.pop();
            _ = parts.pop();

            if actual_parts == parts && hash == actual_hash {
                return true;
            }
        }
        false
    }

    pub fn has_file_from_hash(&self, hash_obj: &str) -> bool {
        for (_, hash) in self.get_files() {
            if hash_obj == hash {
                return true;
            }
        }
        false
    }

    pub fn remove_changes(
        &mut self,
        tree_commit: &Option<Tree>,
        logger: &mut Logger,
    ) -> Result<(), CommandError> {
        let mut files = self.files.clone();

        if let Some(mut tree) = tree_commit.clone() {
            for (path, hash) in self.get_files().iter() {
                let (is_in_last_commit, name) = tree.has_blob_from_hash(hash, logger)?;
                if !is_in_last_commit || (name != get_name(&path)?) {
                    logger.log(&format!("Eliminando del staging area: {}", path));
                    files.remove(path);
                }
            }
        } else {
            files = HashMap::new();
        }
        self.files = files;
        Ok(())
    }

    pub fn write_to(&self, stream: &mut dyn Write) -> Result<(), CommandError> {
        if !self.soft_files.is_empty() || !self.soft_unmerged_files.is_empty() {
            return Err(CommandError::FailToSaveStaginArea(
                "No se puede guardar el staging area en el disco porque hay archivos en staging area soft".to_string(),
            ));
        }
        let mut all_keys: Vec<&String> = self
            .files
            .keys()
            .chain(self.unmerged_files.keys())
            .collect();
        let mut len = self.files.len();
        for unmerged_file_path in self.unmerged_files.keys() {
            if let Some((head, common, destin)) = self.unmerged_files.get(unmerged_file_path) {
                if head.is_some() {
                    len += 1;
                }
                if common.is_some() {
                    len += 1;
                }
                if destin.is_some() {
                    len += 1;
                }
            }
        }

        all_keys.sort_unstable();
        write_header(stream, len)?;
        for key in all_keys {
            let Some(entry) = self.files.get(key) else {
                let (common, head, destin) = self.unmerged_files.get(key).unwrap();
                write_conflicting_entry(stream, key, common)?;
                write_conflicting_entry(stream, key, head)?;
                write_conflicting_entry(stream, key, destin)?;
                continue;
            };
            write_entry(stream, key, entry)?;
        }
        Ok(())
    }

    pub fn read_from(stream: &mut dyn Read, index_path: &str) -> Result<StagingArea, CommandError> {
        let (files, unmerged_files) = read_entries(stream)?;
        Ok(Self {
            files,
            soft_files: HashMap::new(),
            unmerged_files,
            soft_unmerged_files:
                HashMap::<String, (Option<String>, Option<String>, Option<String>)>::new(),
            index_path: index_path.to_string(),
        })
    }

    pub fn open(git_path: &str) -> Result<StagingArea, CommandError> {
        let index_path = join_paths!(git_path, "index").ok_or(
            CommandError::FailToOpenStaginArea("No se pudo abrir el archivo index".to_string()),
        )?;
        match std::fs::File::open(&index_path) {
            Err(_) => Ok(StagingArea::new(&index_path)),
            Ok(mut file) => StagingArea::read_from(&mut file, &index_path),
        }
    }

    pub fn save(&self) -> Result<(), CommandError> {
        match std::fs::File::create(&self.index_path) {
            Err(error) => Err(CommandError::FailToSaveStaginArea(error.to_string())),
            Ok(mut file) => self.write_to(&mut file),
        }
    }

    pub fn add(
        &mut self,
        repo_path: &str,
        file_path: &str,
        hash: &str,
    ) -> Result<(), CommandError> {
        let key: String = if file_path.to_string().starts_with("./") {
            file_path[2..].to_string()
        } else {
            file_path.to_string()
        };
        if self.unmerged_files.contains_key(&key) {
            _ = self.unmerged_files.remove(&key);
        }
        let file_path_meta =
            join_paths!(repo_path, key).ok_or(CommandError::AddStagingAreaError(
                key.clone(),
                "No se pudo abrir el archivo".to_string(),
            ))?;
        let metadata = fs::metadata(file_path_meta)
            .map_err(|error| CommandError::AddStagingAreaError(key.clone(), error.to_string()))?;
        self.files.insert(key, IndexEntry::new(&metadata, hash)?);
        Ok(())
    }

    pub fn add_unmerged_file(
        &mut self,
        repo_path: &str,
        file_path: &str,
        common_hash: Option<String>,
        head_hash: Option<String>,
        destin_hash: Option<String>,
    ) -> Result<(), CommandError> {
        let key: String = if file_path.to_string().starts_with("./") {
            file_path[2..].to_string()
        } else {
            file_path.to_string()
        };
        if self.files.contains_key(&key) {
            _ = self.files.remove(&key);
        }
        let file_path_meta =
            join_paths!(repo_path, key).ok_or(CommandError::AddStagingAreaError(
                repo_path.to_string(),
                "No se pudo abrir el archivo".to_string(),
            ))?;
        let metadata = fs::metadata(file_path_meta.clone()).map_err(|error| {
            CommandError::AddStagingAreaError(file_path_meta, error.to_string())
        })?;

        let common_entry = new_conflicting_entry(&common_hash, &metadata, MergeStage::Common)?;
        let head_entry = new_conflicting_entry(&head_hash, &metadata, MergeStage::Head)?;
        let destin_entry = new_conflicting_entry(&destin_hash, &metadata, MergeStage::Destin)?;
        self.unmerged_files
            .insert(key, (common_entry, head_entry, destin_entry));
        Ok(())
    }

    pub fn soft_add(
        &mut self,
        repo_path: &str,
        file_path: &str,
        hash: &str,
    ) -> Result<(), CommandError> {
        let key: String = if file_path.to_string().starts_with("./") {
            file_path[2..].to_string()
        } else {
            file_path.to_string()
        };
        if self.unmerged_files.contains_key(&key) {
            _ = self.unmerged_files.remove(&key);
        }

        self.soft_files.insert(key, hash.to_owned());
        Ok(())
    }

    pub fn soft_add_unmerged_file(
        &mut self,
        repo_path: &str,
        file_path: &str,
        common_hash: Option<String>,
        head_hash: Option<String>,
        destin_hash: Option<String>,
    ) -> Result<(), CommandError> {
        let key: String = if file_path.to_string().starts_with("./") {
            file_path[2..].to_string()
        } else {
            file_path.to_string()
        };
        _ = self.files.remove(&key);
        _ = self.soft_files.remove(&key);

        self.soft_unmerged_files
            .insert(key, (common_hash, head_hash, destin_hash));
        Ok(())
    }

    pub fn remove(&mut self, path: &str) {
        self.files.remove(path);
    }

    pub fn get_working_tree_staged(&mut self, logger: &mut Logger) -> Result<Tree, CommandError> {
        let current_dir_display = "";
        let mut working_tree = Tree::new(current_dir_display.to_string());
        let files = self.sort_files();
        for (path, hash) in files.iter() {
            let vector_path = path.split("/").collect::<Vec<_>>();
            let current_depth: usize = 0;
            let blob = Blob::new_from_hash_path_and_mode(
                hash.to_string(),
                path.to_string(),
                Mode::RegularFile,
            )?;
            working_tree.add_path_tree(logger, vector_path, current_depth, blob)?;
        }
        logger.log("Working tree staged built");
        Ok(working_tree)
    }

    pub fn get_working_tree_staged_bis(
        &mut self,
        last_commit_tree: &Option<Tree>,
        logger: &mut Logger,
        new_files: Vec<String>,
    ) -> Result<Tree, CommandError> {
        let current_dir_display = "";
        let mut working_tree = Tree::new(current_dir_display.to_string());
        let files = self.sort_files();
        for (path, hash) in files.iter() {
            let is_in_last_commit = {
                if let Some(mut tree) = last_commit_tree.clone() {
                    let (has_hash, name) = tree.has_blob_from_hash(hash, logger)?;

                    has_hash && get_name(path)? == name
                } else {
                    false
                }
            };

            if new_files.contains(path) || is_in_last_commit {
                let vector_path = path.split("/").collect::<Vec<_>>();
                let current_depth: usize = 0;
                let blob = Blob::new_from_hash_path_and_mode(
                    hash.to_string(),
                    path.to_string(),
                    Mode::RegularFile,
                )?;
                working_tree.add_path_tree(logger, vector_path, current_depth, blob)?;
            }
        }
        Ok(working_tree)
    }

    fn sort_files(&mut self) -> Vec<(String, String)> {
        let mut keys: Vec<&String> = self.files.keys().collect();
        keys.sort();

        let mut sorted_files: Vec<(String, String)> = Vec::new();
        for key in keys {
            if let Some(value) = self.get_files().get(key) {
                sorted_files.push((key.clone(), value.clone()));
            }
        }
        sorted_files
    }

    pub fn clear(&mut self) {
        self.files.clear();
        self.unmerged_files.clear();
    }

    pub fn update_to_tree(
        &mut self,
        repo_path: &str,
        working_dir: &Tree,
    ) -> Result<(), CommandError> {
        self.files.clear();
        let mut boxed_working_dir: GitObject = Box::new(working_dir.to_owned());
        self.add_object(repo_path, &mut boxed_working_dir, "")?;
        Ok(())
    }

    pub fn add_object(
        &mut self,
        repo_path: &str,
        object: &mut GitObject,
        obj_path: &str,
    ) -> Result<(), CommandError> {
        if let Some(blob) = object.as_mut_blob() {
            self.add(repo_path, &obj_path, &blob.get_hash_string()?)?;
        } else if let Some(tree) = object.as_mut_tree() {
            for (name, (_, child_obj_opt)) in tree.get_objects() {
                let Some(mut child_object) = child_obj_opt else {
                    return Err(CommandError::ShallowTree);
                };
                let path = join_paths!(obj_path, name).ok_or(
                    CommandError::FailToSaveStaginArea("Fail to join paths".to_string()),
                )?;
                self.add_object(repo_path, &mut child_object, &path)?;
            }
        }
        Ok(())
    }

    pub fn add_unmerged_object(
        &mut self,
        repo_path: &str,
        original_object: &mut GitObject,
        modiffied_object: &mut GitObject,
        obj_path: &str,
        modiffied_object_is_head: bool,
    ) -> Result<(), CommandError> {
        if let Some(modiffied_object_blob) = modiffied_object.as_mut_blob() {
            let Some(original_object_blob) = original_object.as_mut_blob() else {
                return Err(CommandError::CannotHaveFileAndFolderWithSameName(
                    obj_path.to_string(),
                ));
            };
            if modiffied_object_is_head {
                self.add_unmerged_file(
                    repo_path,
                    &obj_path,
                    Some(original_object_blob.get_hash_string()?),
                    Some(modiffied_object_blob.get_hash_string()?),
                    None,
                )?;
            } else {
                self.add_unmerged_file(
                    repo_path,
                    &obj_path,
                    Some(original_object.get_hash_string()?),
                    None,
                    Some(modiffied_object.get_hash_string()?),
                )?;
            }
        } else if let Some(modiffied_object_tree) = modiffied_object.as_mut_tree() {
            let Some(original_object_tree) = original_object.as_mut_tree() else {
                return Err(CommandError::CannotHaveFileAndFolderWithSameName(
                    obj_path.to_string(),
                ));
            };
            for (name, (_, modiffied_object_child_opt)) in modiffied_object_tree.get_objects() {
                let Some(mut modiffied_object_child) = modiffied_object_child_opt else {
                    return Err(CommandError::ShallowTree);
                };
                let path = join_paths!(obj_path, name).ok_or(
                    CommandError::FailToSaveStaginArea("Fail to join paths".to_string()),
                )?;
                let (_, original_obj_opt) = original_object_tree
                    .get_objects()
                    .get(&name)
                    .ok_or(CommandError::CannotHaveFileAndFolderWithSameName(
                        obj_path.to_string(),
                    ))?
                    .to_owned();
                let Some(mut original) = original_obj_opt else {
                    return Err(CommandError::ShallowTree);
                };
                self.add_unmerged_object(
                    repo_path,
                    &mut original,
                    &mut modiffied_object_child,
                    &path,
                    modiffied_object_is_head,
                )?;
            }
        }
        Ok(())
    }

    pub fn soft_add_object(
        &mut self,
        repo_path: &str,
        object: &mut GitObject,
        obj_path: &str,
    ) -> Result<(), CommandError> {
        if let Some(blob) = object.as_mut_blob() {
            self.soft_add(repo_path, &obj_path, &blob.get_hash_string()?)?;
        } else if let Some(tree) = object.as_mut_tree() {
            for (name, (_, child_obj_opt)) in tree.get_objects() {
                let Some(mut child_object) = child_obj_opt else {
                    return Err(CommandError::ShallowTree);
                };
                let path = join_paths!(obj_path, name).ok_or(
                    CommandError::FailToSaveStaginArea("Fail to join paths".to_string()),
                )?;
                self.soft_add_object(repo_path, &mut child_object, &path)?;
            }
        }
        Ok(())
    }

    pub fn soft_add_unmerged_object(
        &mut self,
        repo_path: &str,
        original_object: &mut GitObject,
        modiffied_object: &mut GitObject,
        obj_path: &str,
        modiffied_object_is_head: bool,
    ) -> Result<(), CommandError> {
        if let Some(modiffied_object_blob) = modiffied_object.as_mut_blob() {
            let Some(original_object_blob) = original_object.as_mut_blob() else {
                return Err(CommandError::CannotHaveFileAndFolderWithSameName(
                    obj_path.to_string(),
                ));
            };
            if modiffied_object_is_head {
                self.soft_add_unmerged_file(
                    repo_path,
                    &obj_path,
                    Some(original_object_blob.get_hash_string()?),
                    Some(modiffied_object_blob.get_hash_string()?),
                    None,
                )?;
            } else {
                self.soft_add_unmerged_file(
                    repo_path,
                    &obj_path,
                    Some(original_object.get_hash_string()?),
                    None,
                    Some(modiffied_object.get_hash_string()?),
                )?;
            }
        } else if let Some(modiffied_object_tree) = modiffied_object.as_mut_tree() {
            let Some(original_object_tree) = original_object.as_mut_tree() else {
                return Err(CommandError::CannotHaveFileAndFolderWithSameName(
                    obj_path.to_string(),
                ));
            };
            for (name, (_, modiffied_object_child_opt)) in modiffied_object_tree.get_objects() {
                let Some(mut modiffied_object_child) = modiffied_object_child_opt else {
                    return Err(CommandError::ShallowTree);
                };
                let path = join_paths!(obj_path, name).ok_or(
                    CommandError::FailToSaveStaginArea("Fail to join paths".to_string()),
                )?;
                let (_, original_obj_opt) = original_object_tree
                    .get_objects()
                    .get(&name)
                    .ok_or(CommandError::CannotHaveFileAndFolderWithSameName(
                        obj_path.to_string(),
                    ))?
                    .to_owned();
                let Some(mut original) = original_obj_opt else {
                    return Err(CommandError::ShallowTree);
                };
                self.soft_add_unmerged_object(
                    repo_path,
                    &mut original,
                    &mut modiffied_object_child,
                    &path,
                    modiffied_object_is_head,
                )?;
            }
        }
        Ok(())
    }

    pub fn has_conflicts(&self) -> bool {
        !self.unmerged_files.is_empty() || !self.soft_unmerged_files.is_empty()
    }

    pub fn is_umgerged(&self, path: &str) -> bool {
        self.unmerged_files.contains_key(path)
    }

    pub fn flush_soft_files(&mut self, repo_path: &str) -> Result<(), CommandError> {
        for (path, hash) in self.soft_files.clone() {
            self.add(repo_path, &path, &hash)?;
        }
        self.soft_files.clear();
        for (path, (common, head, destin)) in self.soft_unmerged_files.clone() {
            self.add_unmerged_file(
                repo_path,
                &path,
                common.to_owned(),
                head.to_owned(),
                destin.to_owned(),
            )?;
        }
        self.soft_unmerged_files.clear();
        Ok(())
    }
}

fn write_header(stream: &mut dyn Write, len: usize) -> Result<(), CommandError> {
    stream
        .write(&"DIRC".as_bytes())
        .map_err(|error| CommandError::FailToSaveStaginArea(error.to_string()))?;
    stream
        .write(&[0, 0, 0, 2])
        .map_err(|error| CommandError::FailToSaveStaginArea(error.to_string()))?;
    stream
        .write(&(len as u32).to_be_bytes())
        .map_err(|error| CommandError::FailToSaveStaginArea(error.to_string()))?;
    Ok(())
}

fn write_conflicting_entry(
    stream: &mut dyn Write,
    path: &str,
    entry: &Option<IndexEntry>,
) -> Result<(), CommandError> {
    if let Some(entry) = entry {
        write_entry(stream, path, entry)?;
    }
    Ok(())
}

fn write_entry(stream: &mut dyn Write, path: &str, entry: &IndexEntry) -> Result<(), CommandError> {
    entry.write_to(stream, path)
}

fn new_conflicting_entry(
    common_hash: &Option<String>,
    metadata: &Metadata,
    stage: MergeStage,
) -> Result<Option<IndexEntry>, CommandError> {
    match common_hash {
        Some(hash) => Ok(Some(IndexEntry::new_conflicting(metadata, &hash, stage)?)),
        None => Ok(None),
    }
}

fn read_entries(
    stream: &mut dyn Read,
) -> Result<
    (
        HashMap<String, IndexEntry>,
        HashMap<String, (Option<IndexEntry>, Option<IndexEntry>, Option<IndexEntry>)>,
    ),
    CommandError,
> {
    let mut files = HashMap::<String, IndexEntry>::new();
    let mut unmerged_files =
        HashMap::<String, (Option<IndexEntry>, Option<IndexEntry>, Option<IndexEntry>)>::new();
    let mut magic_bytes = [0; 4];
    stream
        .read_exact(&mut magic_bytes)
        .map_err(|error| CommandError::FileReadError(error.to_string()))?;
    if magic_bytes != "DIRC".as_bytes() {
        return Err(CommandError::FileReadError(
            "Magic bytes no coinciden".to_string(),
        ));
    }
    let mut version_bytes = [0; 4];
    stream
        .read_exact(&mut version_bytes)
        .map_err(|error| CommandError::FileReadError(error.to_string()))?;
    let version = u32::from_be_bytes(version_bytes);
    if version != 2 {
        return Err(CommandError::FileReadError(format!(
            "Version no soportada: {}",
            version
        )));
    }
    let mut entries_count_bytes = [0; 4];
    stream
        .read_exact(&mut entries_count_bytes)
        .map_err(|error| CommandError::FileReadError(error.to_string()))?;
    let entries_count = u32::from_be_bytes(entries_count_bytes);
    for _ in 0..entries_count {
        let (path, entry) = IndexEntry::read_from_stream(stream)?;
        if entry.stage == MergeStage::RegularFile {
            files.insert(path.to_string(), entry);
        } else {
            let (common, head, destin) = unmerged_files
                .entry(path.to_string())
                .or_insert((None, None, None));
            match entry.stage {
                MergeStage::Common => *common = Some(entry),
                MergeStage::Head => *head = Some(entry),
                MergeStage::Destin => *destin = Some(entry),
                _ => (),
            }
        }
    }
    let mut rest = Vec::new();
    stream
        .read_to_end(&mut rest)
        .map_err(|error| CommandError::FileReadError(error.to_string()))?;

    Ok((files, unmerged_files))
}

// Unit tests
#[cfg(test)]
mod tests {
    use crate::{
        staging_area_components::{index_entry_type::IndexEntryType, staging_area},
        utils::aux::hex_string_to_u8_vec,
    };

    use super::*;
    use std::io::Cursor;

    #[test]
    fn extracting_information_from_index_file() {
        // Index creado con git canónico
        let content = vec![
            0x44, 0x49, 0x52, 0x43, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x65, 0x66,
            0x97, 0xef, 0x2e, 0x83, 0x96, 0xe0, 0x65, 0x66, 0x97, 0xef, 0x2e, 0x83, 0x96, 0xe0,
            0x00, 0x00, 0x00, 0x2d, 0x01, 0x17, 0xa3, 0xcf, 0x00, 0x00, 0x81, 0xa4, 0x00, 0x00,
            0x03, 0xe8, 0x00, 0x00, 0x03, 0xe8, 0x00, 0x00, 0x00, 0x04, 0x5e, 0x40, 0xc0, 0x87,
            0x70, 0x58, 0xc5, 0x04, 0x20, 0x39, 0x32, 0xe5, 0x13, 0x60, 0x51, 0xcf, 0x3c, 0xd3,
            0x51, 0x9b, 0x00, 0x04, 0x66, 0x69, 0x6c, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xe0, 0x5d, 0xd7, 0xd9, 0x4a, 0x99, 0x74, 0x02, 0xa9, 0x87, 0x09, 0xb6, 0x28, 0x57,
            0xc3, 0x0f, 0x12, 0x2a, 0xd4, 0xd4,
        ];
        let mut file = Cursor::new(&content);
        let staging_area = StagingArea::read_from(&mut file, "").unwrap();
        let files = staging_area.clone().files;
        let unmerged_files = staging_area.clone().unmerged_files;
        assert_eq!(files.len(), 1);
        assert!(unmerged_files.is_empty());
        let entry = files.get("file").unwrap();
        assert_eq!(entry.ctime, (1701222383, 780375776));
        assert_eq!(entry.mtime, (1701222383, 780375776));
        assert_eq!(entry.dev, 45);
        assert_eq!(entry.ino, 18326479);
        assert_eq!(entry.entry_type, IndexEntryType::RegularFile);
        assert_eq!(entry.unix_permission, 420); // 644 es la representación octal de 420
        assert_eq!(entry.uid, 1000);
        assert_eq!(entry.gid, 1000);
        assert_eq!(entry.fsize, 4);
        assert_eq!(
            entry.sha1,
            hex_string_to_u8_vec("5e40c0877058c504203932e5136051cf3cd3519b")
        );
        assert_eq!(entry.assume_valid, false);
        assert_eq!(entry.stage, MergeStage::RegularFile);

        let mut file_content_2 = Vec::<u8>::new();
        let mut writer_2 = Cursor::new(&mut file_content_2);
        staging_area.write_to(&mut writer_2).unwrap();
        let mut reader_2 = Cursor::new(&mut file_content_2);
        let staging_area_2 = StagingArea::read_from(&mut reader_2, "").unwrap();
        assert_eq!(staging_area, staging_area_2);
    }

    #[test]
    fn extracting_information_from_index_file_with_two_files() {
        // Index creado con git canónico
        let content = vec![
            0x44, 0x49, 0x52, 0x43, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x65, 0x67,
            0x87, 0x30, 0x22, 0xcd, 0x80, 0xd2, 0x65, 0x67, 0x87, 0x30, 0x22, 0xcd, 0x80, 0xd2,
            0x00, 0x00, 0x00, 0x2d, 0x01, 0x18, 0x1b, 0x70, 0x00, 0x00, 0x81, 0xa4, 0x00, 0x00,
            0x03, 0xe8, 0x00, 0x00, 0x03, 0xe8, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x9d, 0xe2, 0x9b,
            0xb2, 0xd1, 0xd6, 0x43, 0x4b, 0x8b, 0x29, 0xae, 0x77, 0x5a, 0xd8, 0xc2, 0xe4, 0x8c,
            0x53, 0x91, 0x00, 0x05, 0x66, 0x69, 0x6c, 0x65, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x65, 0x67, 0x87, 0x32, 0x0f, 0x31, 0x6c, 0x44, 0x65, 0x67, 0x87, 0x32, 0x0f, 0x31,
            0x6c, 0x44, 0x00, 0x00, 0x00, 0x2d, 0x01, 0x18, 0x1b, 0x71, 0x00, 0x00, 0x81, 0xa4,
            0x00, 0x00, 0x03, 0xe8, 0x00, 0x00, 0x03, 0xe8, 0x00, 0x00, 0x00, 0x00, 0xe6, 0x9d,
            0xe2, 0x9b, 0xb2, 0xd1, 0xd6, 0x43, 0x4b, 0x8b, 0x29, 0xae, 0x77, 0x5a, 0xd8, 0xc2,
            0xe4, 0x8c, 0x53, 0x91, 0x00, 0x05, 0x66, 0x69, 0x6c, 0x65, 0x32, 0x00, 0x00, 0x00,
            0x00, 0x00, 0xb9, 0x47, 0x11, 0xca, 0x82, 0x76, 0x06, 0x5c, 0xe9, 0xac, 0x44, 0xde,
            0xd8, 0x05, 0x5b, 0x00, 0x35, 0x1d, 0xce, 0xd9,
        ];
        let mut file = Cursor::new(content);
        let (files, unmerged_files) = read_entries(&mut file).unwrap();
        assert_eq!(files.len(), 2);
        assert!(unmerged_files.is_empty());
        let entry_1 = files.get("file1").unwrap();
        assert_eq!(entry_1.ctime, (1701283632, 583893202));
        assert_eq!(entry_1.mtime, (1701283632, 583893202));
        assert_eq!(entry_1.dev, 45);
        assert_eq!(entry_1.ino, 18357104);
        assert_eq!(entry_1.entry_type, IndexEntryType::RegularFile);
        assert_eq!(entry_1.unix_permission, 420); // 644 es la representación octal de 420
        assert_eq!(entry_1.uid, 1000);
        assert_eq!(entry_1.gid, 1000);
        assert_eq!(entry_1.fsize, 0);
        assert_eq!(
            entry_1.sha1,
            hex_string_to_u8_vec("e69de29bb2d1d6434b8b29ae775ad8c2e48c5391")
        );
        assert_eq!(entry_1.assume_valid, false);
        assert_eq!(entry_1.stage, MergeStage::RegularFile);
        let entry_2 = files.get("file2").unwrap();
        assert_eq!(entry_2.ctime, (1701283634, 254897220));
        assert_eq!(entry_2.mtime, (1701283634, 254897220));
        assert_eq!(entry_2.dev, 45);
        assert_eq!(entry_2.ino, 18357105);
        assert_eq!(entry_2.entry_type, IndexEntryType::RegularFile);
        assert_eq!(entry_2.unix_permission, 420); // 644 es la representación octal de 420
        assert_eq!(entry_2.uid, 1000);
        assert_eq!(entry_2.gid, 1000);
        assert_eq!(entry_2.fsize, 0);
        assert_eq!(
            entry_2.sha1,
            hex_string_to_u8_vec("e69de29bb2d1d6434b8b29ae775ad8c2e48c5391")
        );
        assert_eq!(entry_2.assume_valid, false);
        assert_eq!(entry_2.stage, MergeStage::RegularFile);
    }

    #[test]
    fn extracting_information_from_complex_index_file() {
        // Index creado con git canónico
        let content = vec![
            0x44, 0x49, 0x52, 0x43, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x65, 0x67,
            0x72, 0x05, 0x21, 0x65, 0x78, 0x80, 0x65, 0x67, 0x5c, 0x68, 0x21, 0xbe, 0xe0, 0x00,
            0x00, 0x00, 0x00, 0x2d, 0x01, 0x17, 0xf4, 0xcb, 0x00, 0x00, 0x81, 0xed, 0x00, 0x00,
            0x03, 0xe8, 0x00, 0x00, 0x03, 0xe8, 0x00, 0x00, 0x00, 0x0c, 0xfb, 0x6f, 0x80, 0x94,
            0x90, 0x23, 0x61, 0xd8, 0x8f, 0x3a, 0xa5, 0x04, 0x8b, 0x7d, 0x3a, 0x36, 0x19, 0x45,
            0xd1, 0x99, 0x0f, 0xe4, 0x64, 0x69, 0x72, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6c, 0x61, 0x72, 0x67, 0x6f, 0x2f, 0x64, 0x69, 0x72, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6c, 0x61, 0x72, 0x67, 0x6f, 0x2f, 0x64, 0x69, 0x72, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6c, 0x61, 0x72, 0x67, 0x6f, 0x2f, 0x64, 0x69, 0x72, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6c, 0x61, 0x72, 0x67, 0x6f, 0x2f, 0x64, 0x69,
            0x72, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6c, 0x61, 0x72, 0x67, 0x6f, 0x2f,
            0x64, 0x69, 0x72, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6c, 0x61, 0x72, 0x67,
            0x6f, 0x2f, 0x64, 0x69, 0x72, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6c, 0x61,
            0x72, 0x67, 0x6f, 0x2f, 0x64, 0x69, 0x72, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6c, 0x61, 0x72, 0x67, 0x6f, 0x2f, 0x64, 0x69, 0x72, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6c, 0x61, 0x72, 0x67, 0x6f, 0x2f, 0x64, 0x69, 0x72, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6c, 0x61, 0x72, 0x67, 0x6f, 0x2f, 0x64, 0x69, 0x72, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6c, 0x61, 0x72, 0x67, 0x6f, 0x2f, 0x64, 0x69,
            0x72, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6c, 0x61, 0x72, 0x67, 0x6f, 0x2f,
            0x64, 0x69, 0x72, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6c, 0x61, 0x72, 0x67,
            0x6f, 0x2f, 0x64, 0x69, 0x72, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6c, 0x61,
            0x72, 0x67, 0x6f, 0x2f, 0x64, 0x69, 0x72, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6c, 0x61, 0x72, 0x67, 0x6f, 0x2f, 0x64, 0x69, 0x72, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f,
            0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75, 0x79, 0x5f, 0x6d, 0x75,
            0x79, 0x5f, 0x6c, 0x61, 0x72, 0x67, 0x6f, 0x2f, 0x66, 0x69, 0x6c, 0x65, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x65, 0x66, 0x97, 0xef, 0x2e, 0x83, 0x96, 0xe0, 0x65, 0x66,
            0x97, 0xef, 0x2e, 0x83, 0x96, 0xe0, 0x00, 0x00, 0x00, 0x2d, 0x01, 0x17, 0xa3, 0xcf,
            0x00, 0x00, 0x81, 0xa4, 0x00, 0x00, 0x03, 0xe8, 0x00, 0x00, 0x03, 0xe8, 0x00, 0x00,
            0x00, 0x04, 0x5e, 0x40, 0xc0, 0x87, 0x70, 0x58, 0xc5, 0x04, 0x20, 0x39, 0x32, 0xe5,
            0x13, 0x60, 0x51, 0xcf, 0x3c, 0xd3, 0x51, 0x9b, 0x00, 0x04, 0x66, 0x69, 0x6c, 0x65,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77, 0xa9, 0x5d, 0x5c, 0x55, 0x93, 0x5f, 0xa1,
            0x7a, 0x70, 0xbc, 0xd4, 0x34, 0x11, 0xa1, 0x70, 0x89, 0xf0, 0x05, 0xe1,
        ];
        let mut file = Cursor::new(content);
        let (files, unmerged_files) = read_entries(&mut file).unwrap();
        assert_eq!(files.len(), 2);
        assert!(unmerged_files.is_empty());
        let entry_file = files.get("file").unwrap();
        assert_eq!(entry_file.ctime, (1701222383, 780375776));
        assert_eq!(entry_file.mtime, (1701222383, 780375776));
        assert_eq!(entry_file.dev, 45);
        assert_eq!(entry_file.ino, 18326479);
        assert_eq!(entry_file.entry_type, IndexEntryType::RegularFile);
        assert_eq!(entry_file.unix_permission, 420); // 644 es la representación octal de 420
        assert_eq!(entry_file.uid, 1000);
        assert_eq!(entry_file.gid, 1000);
        assert_eq!(entry_file.fsize, 4);
        assert_eq!(
            entry_file.sha1,
            hex_string_to_u8_vec("5e40c0877058c504203932e5136051cf3cd3519b")
        );
        assert_eq!(entry_file.assume_valid, false);
        assert_eq!(entry_file.stage, MergeStage::RegularFile);
        let entry_dir_file = files.get("dir_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_largo/dir_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_largo/dir_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_largo/dir_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_largo/dir_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_largo/dir_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_largo/dir_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_largo/dir_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_largo/dir_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_largo/dir_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_largo/dir_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_largo/dir_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_largo/dir_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_largo/dir_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_largo/dir_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_largo/dir_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_muy_largo/file").unwrap();
        assert_eq!(entry_dir_file.ctime, (1701278213, 560298112));
        assert_eq!(entry_dir_file.mtime, (1701272680, 566157312));
        assert_eq!(entry_dir_file.dev, 45);
        assert_eq!(entry_dir_file.ino, 18347211);
        assert_eq!(entry_dir_file.entry_type, IndexEntryType::RegularFile);
        assert_eq!(entry_dir_file.unix_permission, 493); // 0755 es la representación octal de 493
        assert_eq!(entry_dir_file.uid, 1000);
        assert_eq!(entry_dir_file.gid, 1000);
        assert_eq!(entry_dir_file.fsize, 12);
        assert_eq!(
            entry_dir_file.sha1,
            hex_string_to_u8_vec("fb6f8094902361d88f3aa5048b7d3a361945d199")
        );
        assert_eq!(entry_dir_file.assume_valid, false);
        assert_eq!(entry_dir_file.stage, MergeStage::RegularFile);
    }

    #[test]
    fn extracting_information_from_index_file_with_merge_conflicts() {
        // Index creado con git canónico
        let content = vec![
            0x44, 0x49, 0x52, 0x43, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0xa4, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0x30, 0xa4, 0xfc,
            0x6d, 0x44, 0xda, 0x29, 0xd4, 0x19, 0x05, 0x70, 0x9d, 0x0b, 0xc1, 0x73, 0x58, 0xe9,
            0x17, 0x4e, 0x10, 0x04, 0x66, 0x69, 0x6c, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0xa4,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5f, 0x3b,
            0x03, 0x28, 0xf4, 0x65, 0xda, 0x18, 0xd8, 0x7f, 0x8b, 0xaf, 0x7b, 0x00, 0x10, 0xc5,
            0xf0, 0xdb, 0x50, 0xf2, 0x20, 0x04, 0x66, 0x69, 0x6c, 0x65, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x81, 0xa4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xfb, 0x6f, 0x80, 0x94, 0x90, 0x23, 0x61, 0xd8, 0x8f, 0x3a, 0xa5, 0x04, 0x8b, 0x7d,
            0x3a, 0x36, 0x19, 0x45, 0xd1, 0x99, 0x30, 0x04, 0x66, 0x69, 0x6c, 0x65, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x54, 0x52, 0x45, 0x45, 0x00, 0x00, 0x00, 0x06, 0x00, 0x2d,
            0x31, 0x20, 0x30, 0x0a, 0x7c, 0x3c, 0x73, 0xef, 0x98, 0xf6, 0x11, 0xec, 0xa0, 0x18,
            0x2b, 0xf2, 0xb4, 0x6b, 0xc6, 0x30, 0x0f, 0x01, 0xf9, 0xb0,
        ];
        let mut file = Cursor::new(content);
        let (files, mut unmerged_files) = read_entries(&mut file).unwrap();
        assert_eq!(unmerged_files.len(), 1);
        assert!(files.is_empty());
        let (common, head, destin) = unmerged_files.get_mut("file").unwrap();
        let common = common.as_mut().unwrap();
        let head = head.as_mut().unwrap();
        let destin = destin.as_mut().unwrap();

        assert_eq!(common.ctime, (0, 0));
        assert_eq!(common.mtime, (0, 0));
        assert_eq!(common.dev, 0);
        assert_eq!(common.ino, 0);
        assert_eq!(common.entry_type, IndexEntryType::RegularFile);
        assert_eq!(common.unix_permission, 420); // 644 es la representación octal de 420
        assert_eq!(common.uid, 0);
        assert_eq!(common.gid, 0);
        assert_eq!(common.fsize, 0);
        assert_eq!(
            common.sha1,
            hex_string_to_u8_vec("8830a4fc6d44da29d41905709d0bc17358e9174e")
        );
        assert_eq!(common.assume_valid, false);
        assert_eq!(common.stage, MergeStage::Common);

        assert_eq!(head.ctime, (0, 0));
        assert_eq!(head.mtime, (0, 0));
        assert_eq!(head.dev, 0);
        assert_eq!(head.ino, 0);
        assert_eq!(head.entry_type, IndexEntryType::RegularFile);
        assert_eq!(head.unix_permission, 420); // 644 es la representación octal de 420
        assert_eq!(head.uid, 0);
        assert_eq!(head.gid, 0);
        assert_eq!(head.fsize, 0);
        assert_eq!(
            head.sha1,
            hex_string_to_u8_vec("5f3b0328f465da18d87f8baf7b0010c5f0db50f2")
        );
        assert_eq!(head.assume_valid, false);
        assert_eq!(head.stage, MergeStage::Head);

        assert_eq!(destin.ctime, (0, 0));
        assert_eq!(destin.mtime, (0, 0));
        assert_eq!(destin.dev, 0);
        assert_eq!(destin.ino, 0);
        assert_eq!(destin.entry_type, IndexEntryType::RegularFile);
        assert_eq!(destin.unix_permission, 420); // 644 es la representación octal de 420
        assert_eq!(destin.uid, 0);
        assert_eq!(destin.gid, 0);
        assert_eq!(destin.fsize, 0);
        assert_eq!(
            destin.sha1,
            hex_string_to_u8_vec("fb6f8094902361d88f3aa5048b7d3a361945d199")
        );
        assert_eq!(destin.assume_valid, false);
        assert_eq!(destin.stage, MergeStage::Destin);
    }

    #[test]
    fn extracting_information_from_index_file_merged() {
        // Index creado con git canónico
        let content = vec![
            0x44, 0x49, 0x52, 0x43, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x65, 0x67,
            0x8c, 0x4b, 0x24, 0x4f, 0x5c, 0x2e, 0x65, 0x67, 0x8c, 0x4b, 0x24, 0x4f, 0x5c, 0x2e,
            0x00, 0x00, 0x00, 0x2d, 0x01, 0x18, 0x08, 0x32, 0x00, 0x00, 0x81, 0xa4, 0x00, 0x00,
            0x03, 0xe8, 0x00, 0x00, 0x03, 0xe8, 0x00, 0x00, 0x00, 0x10, 0xf0, 0x0b, 0x59, 0xb2,
            0xb4, 0x61, 0x40, 0xbc, 0xa6, 0xdc, 0x7f, 0x27, 0x63, 0xfa, 0xb8, 0xa9, 0xce, 0x54,
            0xfb, 0x01, 0x00, 0x04, 0x66, 0x69, 0x6c, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x54, 0x52, 0x45, 0x45, 0x00, 0x00, 0x00, 0x19, 0x00, 0x31, 0x20, 0x30, 0x0a, 0x09,
            0xab, 0xab, 0x23, 0x9a, 0xe5, 0x76, 0xb5, 0x3f, 0xd8, 0x81, 0x67, 0x91, 0x31, 0x3e,
            0xa4, 0x52, 0x5d, 0x16, 0x38, 0x52, 0x45, 0x55, 0x43, 0x00, 0x00, 0x00, 0x56, 0x66,
            0x69, 0x6c, 0x65, 0x00, 0x31, 0x30, 0x30, 0x36, 0x34, 0x34, 0x00, 0x31, 0x30, 0x30,
            0x36, 0x34, 0x34, 0x00, 0x31, 0x30, 0x30, 0x36, 0x34, 0x34, 0x00, 0x88, 0x30, 0xa4,
            0xfc, 0x6d, 0x44, 0xda, 0x29, 0xd4, 0x19, 0x05, 0x70, 0x9d, 0x0b, 0xc1, 0x73, 0x58,
            0xe9, 0x17, 0x4e, 0x5f, 0x3b, 0x03, 0x28, 0xf4, 0x65, 0xda, 0x18, 0xd8, 0x7f, 0x8b,
            0xaf, 0x7b, 0x00, 0x10, 0xc5, 0xf0, 0xdb, 0x50, 0xf2, 0xfb, 0x6f, 0x80, 0x94, 0x90,
            0x23, 0x61, 0xd8, 0x8f, 0x3a, 0xa5, 0x04, 0x8b, 0x7d, 0x3a, 0x36, 0x19, 0x45, 0xd1,
            0x99, 0xf8, 0x66, 0x9f, 0xce, 0x1e, 0x17, 0x9f, 0x4f, 0xdd, 0xb8, 0x00, 0x14, 0x60,
            0xd9, 0x62, 0xef, 0x73, 0xd1, 0x6c, 0x83,
        ];
        let mut file = Cursor::new(content);
        let (files, unmerged_files) = read_entries(&mut file).unwrap();
        assert_eq!(files.len(), 1);
        assert!(unmerged_files.is_empty());
        let entry = files.get("file").unwrap();
        assert_eq!(entry.ctime, (1701284939, 609180718));
        assert_eq!(entry.mtime, (1701284939, 609180718));
        assert_eq!(entry.dev, 45);
        assert_eq!(entry.ino, 18352178);
        assert_eq!(entry.entry_type, IndexEntryType::RegularFile);
        assert_eq!(entry.unix_permission, 420); // 644 es la representación octal de 420
        assert_eq!(entry.uid, 1000);
        assert_eq!(entry.gid, 1000);
        assert_eq!(entry.fsize, 16);
        assert_eq!(
            entry.sha1,
            hex_string_to_u8_vec("f00b59b2b46140bca6dc7f2763fab8a9ce54fb01")
        );
        assert_eq!(entry.assume_valid, false);
        assert_eq!(entry.stage, MergeStage::RegularFile);
    }
}
